<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="simplepeng" /><link rel="canonical" href="http://simplepeng.com/blog/android/%E9%9A%8F%E7%AC%94/%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager/" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>学会自定义LayoutManager - blog</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u5b66\u4f1a\u81ea\u5b9a\u4e49LayoutManager";
        var mkdocs_page_input_path = "android/\u968f\u7b14/\u5b66\u4f1a\u81ea\u5b9a\u4e49LayoutManager.md";
        var mkdocs_page_url = "/blog/android/%E9%9A%8F%E7%AC%94/%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager/";
      </script>
    
    <script src="../../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/kotlin.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> blog
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">主页</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Android</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="#">FFmpeg</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../FFmpeg/%E7%BC%96%E8%AF%91%E5%8F%AF%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84FFmpeg/">编译可执行命令的FFmpeg</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../FFmpeg/%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93/">编译成动态库</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../FFmpeg/%E8%8E%B7%E5%8F%96%E8%A7%86%E9%A2%91%E9%A6%96%E5%B8%A7%E8%BD%ACBitmap%E5%B0%81%E9%9D%A2%E5%9B%BE/">获取视频首帧转Bitmap封面图</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">Jetpack</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../Jetpack/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E2%80%94LiveData/">Android架构组件-LiveData</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Jetpack/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E2%80%94Room/">Android架构组件-Room</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Jetpack/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E2%80%94ViewModel/">Android架构组件—ViewModel</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Jetpack/Architecture%20Components%E4%BB%8B%E7%BB%8D/">Architecture Components介绍</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">NDK</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../NDK/Cmake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Cmake学习笔记</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../NDK/JNI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">JNI学习笔记</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../NDK/JNI%E8%BE%93%E5%87%BA%E5%8E%9F%E7%94%9FLOG/">JNI输出原生LOG</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../NDK/%E7%BB%99%E5%B7%B2%E6%9C%89%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0JNI%E6%94%AF%E6%8C%81/">给已有项目添加JNI/CMake支持</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">源码分析</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%88%91%E5%AF%B9Retrofit%E7%9A%84%E7%90%86%E8%A7%A3/">我对Retrofit的理解</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">自定义View</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../%E8%87%AA%E5%AE%9A%E4%B9%89View/%E8%87%AA%E5%AE%9A%E4%B9%89View%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/">自定义View的构造方法解析</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">逆向</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../%E9%80%86%E5%90%91/%E4%BD%BF%E7%94%A8FRIDA-DEXDump%E8%84%B1%E5%A3%B3/">使用FRIDA-DEXDump脱壳</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../%E9%80%86%E5%90%91/%E4%BD%BF%E7%94%A8MuMu%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%84%B1360%E5%8A%A0%E5%9B%BA%E7%9A%84%E5%A3%B3/">使用MuMu模拟器脱360加固的壳</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">随笔</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" href="../ADB%20%E5%BD%95%E5%88%B6%E5%B1%8F%E5%B9%95%E5%91%BD%E4%BB%A4/">ADB 录制屏幕命令</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../AS%E6%98%BE%E7%A4%BANavigation%E6%A0%87%E7%AD%BE/">AS显示Navigation标签</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../AS%E6%9C%AC%E5%9C%B0Maven%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/">AS本地Maven仓库搭建</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../Android%20Material%20buttons/">[译]Android Material buttons</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../Android%20Selector%E7%9A%84%E7%AE%80%E5%86%99/">Android Selector的简写</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../ConstraintLayout-1.1.0%E6%96%B0%E7%89%B9%E6%80%A7/">ConstraintLayout-1.1.0新特性</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../EventBus%E6%90%AD%E9%85%8DLifeCycle%E5%8F%AF%E8%83%BD%E6%9B%B4%E7%BE%8E%E5%91%B3/">EventBus搭配LifeCycle可能更美味</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../Kotlin%E5%85%A5%E9%97%A8%E8%AE%B2%E8%A7%A3/">Kotlin入门讲解</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../Kotlin%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/">Kotlin内建函数</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../ManifestPlaceholders%E7%9A%84%E5%A6%99%E7%94%A8/">ManifestPlaceholders的妙用</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../MaxLineLayoutManager/">MaxLineLayoutManager</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../PopupMenu%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/">PopupMenu简单使用</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../RxJava%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6/">RxJava常用操作符</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../ViewDragHelper%E7%AE%80%E8%A7%A3/">ViewDragHelper简解</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../ViewPagerTransforms%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/">ViewPagerTransforms的深入理解</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../%5B%E8%AF%91%5D%E4%BB%8EJava%E5%88%87%E6%8D%A2%E5%88%B0Kotlin%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/">[译]从Java切换到Kotlin的新特性</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../%E4%BC%98%E5%8C%96%E5%B5%8C%E5%A5%97%E7%9A%84RecyclerView/">[译]优化嵌套的RecyclerView</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../%E4%BD%BF%E7%94%A8Gradle%E5%92%8CKotlin%E7%BB%84%E7%BB%87Android%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/">使用Gradle和Kotlin组织资源文件</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../%E4%BD%BF%E7%94%A8Parcelize%E6%B3%A8%E8%A7%A3%E7%AE%80%E5%8C%96Parcelable/">使用Parcelize注解简化Parcelable</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../%E4%BD%BF%E7%94%A8Support%E6%B3%A8%E8%A7%A3%E5%8C%85%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91/">使用Support注解包优化代码逻辑</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../%E5%9C%A8Activity%E7%9A%84onCreate%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B0%83%E7%94%A8finish%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Activity的onCreate中调用finish的生命周期</a>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="./">学会自定义LayoutManager</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#layoutmanager_1">一些自定义LayoutManager优秀文章推荐</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#layoutmanager_2">先讲讲自定义LayoutManager的常规套路</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#layoutmanager_3">再说说自定义LayoutManager容易进入的误区</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#recyclerviewlayoutmanager">使用RecyclerView或者说继承了LayoutManager就自带了复用机制和视图回收？</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#onmeasureisautomeasureenabled">未正确的重写onMeasure()或isAutoMeasureEnabled()方法</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#onlayoutchildrenitemview">onLayoutChildren()时直接加载了全部itemView</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#scrolltopositionsmoothscrolltoposition">未支持scrollToPosition()或smoothScrollToPosition()方法</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#onlayoutchildren">未解决软键盘弹出或收起onLayoutChildren()方法重新调用的问题</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#api">一些有用的Api</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#view">获取一个View</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#viewrecyclerview">将View添加到RecyclerView中</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#view_1">测量View</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#view_2">摆放View</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#view_3">获取View的相关信息</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#view_4">移动View</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#view_5">回收View</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#orientationhelper">OrientationHelper帮助类</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#layoutmanager_4">正式开始自定义LayoutManager</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#layoutmanagergeneratedefaultlayoutparams">继承LayoutManager并实现generateDefaultLayoutParams()方法</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#onmeasureisautomeasureenabled_1">重写onMeasure()或isAutoMeasureEnabled()方法。</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#onlayoutchildrenview">重写onLayoutChildren()开始填充子View。</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#canscrollhorizontallycanscrollvertically">重写canScrollHorizontally()和canScrollVertically()方法支持滑动。</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#scrollhorizontallybyscrollverticallybyviewview">重写scrollHorizontallyBy()和scrollVerticallyBy()方法在滑动的时候填充view和回收view。</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#scrolltopositionsmoothscrolltoposition_1">scrollToPosition()和smoothScrollToPosition()方法支持。</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#onlayoutchildren_1">解决软键盘弹出或收起onLayoutChildren()方法重新调用的问题。</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_1">最后</a>
    </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1%E7%A0%94%E7%A9%B6/">无障碍服务研究</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../%E7%94%A8Kotlin%E7%BB%99RecyclerView%E5%86%99%E4%B8%80%E4%B8%AA%E8%B6%85%E7%BA%A7Adapter/">Kotlin封装RecyclerView的Adapter</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../%E8%87%AA%E5%AE%9A%E4%B9%89SnackBar/">自定义SnackBar</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%99%A8/">自定义全局异常捕获器</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">其他</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../%E5%85%B6%E4%BB%96/HenCoder-5%E6%9C%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">HenCoder-5期-学习笔记</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../%E5%85%B6%E4%BB%96/MacOS%2010.10%20%E4%BB%A5%E4%B8%8A%E8%A7%A3%E5%86%B3%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/">MacOS-10.10以上--解决机械键盘按键无法识别</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../%E5%85%B6%E4%BB%96/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9F%B3%E8%A7%86%E9%A2%91%E5%85%A5%E9%97%A8-FFmpeg%28%E5%85%AC%E5%8F%B8%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%29/">移动端音视频入门 FFmpeg(公司技术分享)</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">blog</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>Android &raquo;</li>
          <li>随笔 &raquo;</li><li>学会自定义LayoutManager</li>
    <li class="wy-breadcrumbs-aside">
        <a href="https://github.com/simplepeng/blog/edit/master/docs/android/随笔/学会自定义LayoutManager.md"
          class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>

          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="layoutmanager">学会自定义LayoutManager</h1>
<p>最开始我在学习自定义LayoutManager的时候，也是网上搜文章，看博客，以及一些公众号的推文。刚开始看的时候觉得还是那么回事，但是在慢慢的深入LayoutManager源码才发现很多的文章其实都是不合格，乃至可以说是很误导人的，所以我才想自己写一篇关于自定义LayoutManager的文章，希望能帮助到一部分人能入门自定义LayoutManager吧。</p>
<h2 id="layoutmanager_1">一些自定义LayoutManager优秀文章推荐</h2>
<p>前面虽然说有很多博客是不合格的，但是同样还是有一些优秀的作者的博客对在下启发很大，特别是<strong>Dave</strong>大神<code>building-a-recyclerview-layoutmanager-part</code>的系列的文章，真的是讲得不能再棒了！虽然已经是14年的文章，但是放在当下来看，依然是自定义LayoutManager相关文章的顶峰，虽然文章是英文，但是还是强烈推荐阅读！</p>
<p><a href="http://wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-1/">Building a RecyclerView LayoutManager – Part 1</a></p>
<p><a href="http://wiresareobsolete.com/2014/09/recyclerview-layoutmanager-2/">Building a RecyclerView LayoutManager – Part 2</a></p>
<p><a href="http://wiresareobsolete.com/2015/02/recyclerview-layoutmanager-3/">Building a RecyclerView LayoutManager – Part 3</a></p>
<p>无意中发现了有B站大佬翻译了<strong>Dave</strong>大神讲解自定义LayoutManager的培训视频，这简直是宝藏，建议收藏多次观看。</p>
<p><a href="https://www.bilibili.com/video/BV1fW411A76o">Mastering RecyclerView Layouts</a></p>
<p>其次就是<strong>张旭童</strong>在CSDN发布<code>掌握自定义LayoutManager</code>相关博客，特别是文章中的常见误区和注意事项，建议多次阅读。</p>
<p><a href="https://blog.csdn.net/zxt0601/article/details/52948009">https://blog.csdn.net/zxt0601/article/details/52948009</a></p>
<p>特别是这句话道出了自定义LayoutManager的真谛：<code>一个合格的LayoutManager，childCount数量不应大于屏幕上显示的Item数量，而scrapCache缓存区域的Item数量应该是0</code>，这里建议多读几遍，加深理解。</p>
<p>最后就是<strong>陈小媛</strong>的<code>Android自定义LayoutManager第十一式之飞龙在天</code>，这么大佬的思路总是那么奇特，逻辑总是那么清晰。</p>
<p>https://blog.csdn.net/u011387817/article/details/81875021</p>
<h2 id="layoutmanager_2">先讲讲自定义LayoutManager的常规套路</h2>
<ol>
<li>继承<code>RecyclerView.LayoutManager</code>并实现<code>generateDefaultLayoutParams()</code>方法。</li>
<li>按需，重写<code>onMeasure()</code>或<code>isAutoMeasureEnabled()</code>方法。</li>
<li>重写<code>onLayoutChildren()</code>开始第一次填充itemView。</li>
<li>重写<code>canScrollHorizontally()</code>和<code>canScrollVertically()</code>方法支持滑动。</li>
<li>重写<code>scrollHorizontallyBy()</code>和<code>scrollVerticallyBy()</code>方法在滑动的时候填充和回收itemView。</li>
<li>重写<code>scrollToPosition()</code>和<code>smoothScrollToPosition()</code>方法支持。</li>
<li>解决软键盘弹出或收起导致<code>onLayoutChildren()</code>方法被重新调用的问题。</li>
</ol>
<h2 id="layoutmanager_3">再说说自定义LayoutManager容易进入的误区</h2>
<ol>
<li>使用<code>RecyclerView</code>或者说<code>继承了LayoutManager</code>就自带了复用机制和视图回收</li>
<li>未正确的重写<code>onMeasure()</code>或<code>isAutoMeasureEnabled()</code>方法</li>
<li><code>onLayoutChildren()</code>时直接加载了全部itemView</li>
<li>未支持<code>scrollToPosition()</code>或<code>smoothScrollToPosition()</code>方法</li>
<li>未解决软键盘弹出或收起<code>onLayoutChildren()</code>方法重新调用的问题。</li>
</ol>
<h4 id="recyclerviewlayoutmanager">使用RecyclerView或者说继承了LayoutManager就自带了复用机制和视图回收？</h4>
<p>我发现很多人把RecyclerView想得太完美了，认为RecyclerView天生就自带了复用机制和视图回收，只要使用RecyclerView根本不用关心加载item的数量。其实不用很仔细的阅读RecyclerView的源码也能发现，RecyclerView只不过是一个提供了<code>多级缓存</code>的<code>超级ViewGroup</code>而已。并且RecyclerView只是将自己的<code>onLayout</code>方法完全委托给了LayoutManager，所以继承LayoutManager也不会自带复用机制和视图回收。</p>
<p>用<code>LinearLayoutManager</code>举例，在LinearLayoutManager源码中有一个<code>recycleByLayoutState()</code>方法，它在滚动填充itemView时调用，用来回收超出屏幕的itemView，所以我们在自定义LayoutManager的时候一定要注意，什么时候该回收itemView是由我们开发者自己决定！</p>
<pre><code class="language-java">    @Override
    public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler,
            RecyclerView.State state) {
                ...
        return scrollBy(dx, recycler, state);
    }    

    int scrollBy(int delta, RecyclerView.Recycler recycler, RecyclerView.State state) {
      ...
        fill(recycler, mLayoutState, state, false);
      ...
    }

        int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
            RecyclerView.State state, boolean stopOnFocusable) {
      recycleByLayoutState(recycler, layoutState);
      ...
      layoutChunk()
      ...
      recycleByLayoutState(recycler, layoutState); 
    }

         void recycleByLayoutState(){
       ...
       if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
            recycleViewsFromEnd(recycler, scrollingOffset, noRecycleSpace);
        } else {
            recycleViewsFromStart(recycler, scrollingOffset, noRecycleSpace);
        }
     }

</code></pre>
<h4 id="onmeasureisautomeasureenabled">未正确的重写onMeasure()或isAutoMeasureEnabled()方法</h4>
<p>上面<code>常规套路</code>中我写的是<code>按需</code>重写onMeasure()和isAutoMeasureEnabled()方法，为什么是<code>按需</code>呢？因为<code>LayoutManger</code>的<code>onMeasure()</code>有默认实现，并且<code>isAutoMeasureEnabled()</code>默认返回的<code>false</code>。这也是为啥有些博客或者Github的源码这两个方法都没有重写却依然没有问题的原因所在，因为他们直接把<code>RecyclerView</code>的<code>width</code>和<code>height</code>都设置成了<code>match_parent</code>。当然如果你能确定你的LayoutManager只支持宽高同时要<code>match_parent</code>才能正常使用，也可以这么搞。</p>
<p>那么问题又来了，什么时候重写<code>onMeasure()</code>，什么时候重写<code>isAutoMeasureEnabled()</code>，或者有没有情况同时重写两个方法呢？这里在我阅读了大量源码和源码注释得出的结论就是：不要同时重写两个方法，因为它们是互斥的，看源码你就懂了。重写<code>onMeasure()</code>的情况也极少，除非像我那个<code>PickerLayoutManger</code>一样，要设置一个绝对的高度给LayoutManager。<code>isAutoMeasureEnabled()</code>是自测量模式，给<code>RecyclerView</code>的<code>wrap_content</code>的用的，如果你的LayoutManager要支持<code>wrap_content</code>那就必须重写。</p>
<h4 id="onlayoutchildrenitemview">onLayoutChildren()时直接加载了全部itemView</h4>
<p>网上博客以及Github上有一些Demo，普遍存在下面这种写法：</p>
<pre><code class="language-java"> for (int i = 0; i &lt; getItemCount(); i++) {
            View view = recycler.getViewForPosition(i);
            addView(view);
            ......
 }
</code></pre>
<p>有一说一，能写出这种写法的人真的不是在搞笑吗？在<code>onLayoutChildren</code>的时候直接<code>遍历itemCount</code>然后<code>addView</code>，这真的不是在作死吗？就算有缓存第一次遍历还是会全部走一遍<code>onCreateViewHolder</code>啊，自己就不能把itemCount设个大点的数试试会不会卡死UI渲染吗！当我有这种想法，而且还想去评论区讨教讨教的时候，我又发现了上面那种写法的变种，罢了罢了，这喷子不当也罢😏😏😏。</p>
<pre><code class="language-java"> for (int i = 0; i &lt; getItemCount(); i++) {
            View view = recycler.getViewForPosition(i);
            addView(view);
            ......
              记录一些item的宽高，位置等信息
            .....
            recyler.recycleView(view)
 }
</code></pre>
<p>最简单的测试方法就是把<code>itemCount</code>设置为<code>Int.MAX_VALUE</code>，没有异常发生就算OK。</p>
<h4 id="scrolltopositionsmoothscrolltoposition">未支持scrollToPosition()或smoothScrollToPosition()方法</h4>
<p>这个问题严谨的来讲也不算什么大问题，但是私以为一个合格的LayoutManager的还是应该去适配这两个方法，毕竟<code>RecyclerView</code>的<code>scrollToPosition()</code>和<code>smoothScrollToPosition()</code>只是对LayoutManager这两个方法的封装，特别是一些发布到Github上的开源库更应该去适配这两个方法。</p>
<h4 id="onlayoutchildren">未解决软键盘弹出或收起onLayoutChildren()方法重新调用的问题</h4>
<p>这个问题我发现大多数的人都没注意到，而且有一些开源库也是存在这个问题的。问题出现的根源就是在当<code>EditText</code>获取到焦点导致<code>软键盘弹起或者收起</code>的时候，LayoutManager会重新回调<code>onLayoutChildren()</code>方法。如果一个LayoutManager的<code>onLayoutChildren</code>方法写得不够合理，就会给使用的人带来困扰，详细的内容会放在下面开始自定义LayoutManager再讲。</p>
<p>话说到这里，我在看<code>LinearLayoutManager</code>源码又一次对Google工程师深深的折服，在LinearLayoutManager的<code>onLayoutChildren</code>方法中有一段代码就是对这种问题的处理，并且还是升级版。</p>
<pre><code class="language-java"> final View focused = getFocusedChild()
 ...
 else if (focused != null &amp;&amp; (mOrientationHelper.getDecoratedStart(focused)
                        &gt;= mOrientationHelper.getEndAfterPadding()
                || mOrientationHelper.getDecoratedEnd(focused)
                &lt;= mOrientationHelper.getStartAfterPadding())) {
      mAnchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused));
}
</code></pre>
<p><code>assignFromViewAndKeepVisibleRect</code>方法是关键，有兴趣的可以自己去看看源码。大概逻辑就是：获取到RecyclerView中获取到焦点的那个itemView和它的position，并开始计算其位置，让它保持在软键盘上面的可见范围内。</p>
<h2 id="api">一些有用的Api</h2>
<p>在开始自定义LayoutManager前，先解释一些Api的用法，这样可以更快的进入主题。</p>
<h4 id="view">获取一个View</h4>
<pre><code class="language-kotlin"> val view = recycler.getViewForPosition(position)
</code></pre>
<p>这个方法会从<code>Recycler</code>中获取到一个不会为<code>null</code>的View，如果position超过itemCount或小于0，就会直接抛出异常。内部代码逻辑就是从不同的缓存中拿View，有就直接返回这个View，没有就用<code>onCreateViewHolder</code>创建并返回。</p>
<p><code>Recycler</code>类可以简单理解为一个回收管理站，需要View时就向它要，不需要时就丢给它。</p>
<h4 id="viewrecyclerview">将View添加到RecyclerView中</h4>
<pre><code class="language-java">addDisappearingView(View child)
addDisappearingView(View child, int index)

addView(View child)
addView(View child, int index)
</code></pre>
<p><code>addDisappearingView</code>方法主要用于支持预测动画，例如：<code>notifyItemRemoved</code>时的删除动画</p>
<p><code>addView</code>方法更常用，只要是添加View都需要用到它。</p>
<h4 id="view_1">测量View</h4>
<pre><code class="language-java">measureChild(@NonNull View child, int widthUsed, int heightUsed)
measureChildWithMargins(@NonNull View child, int widthUsed, int heightUsed)
</code></pre>
<p>两个方法都是用来测量View的相关信息，从名字我们也能看出，一个方法是会带上<code>margin</code>计算，另外一个则不会。</p>
<p><code>widthUsed</code>和<code>heightUsed</code>也能从名称看出端倪，一般传0就可以了，跟着<code>LinearLayoutManager</code>写就对了。</p>
<p><strong>注意：</strong>测量View也不一定要使用这两个方法，在特殊的情况下，也可以自己写测量的方法，比如在<code>StaggeredGridLayoutManager</code>中就是自己重写的测量方法<code>measureChildWithDecorationsAndMargin()</code>，以及我的一个开源库<a href="https://github.com/simplepeng/PickerLayoutManager">PickerLayoutManager</a>中在<code>onMeasure</code>中直接使用了<code>view.measure()</code>这种原生方法。</p>
<h4 id="view_2">摆放View</h4>
<pre><code class="language-java">layoutDecorated(@NonNull View child, int left, int top, int right, int bottom)
layoutDecoratedWithMargins(@NonNull View child, int left, int top, int right,
                int bottom) {
</code></pre>
<p>这两个方法没啥好说的，就是对<code>view.layout()</code>的封装，只要写过自定义ViewGroup的人应该也不会陌生。</p>
<h4 id="view_3">获取View的相关信息</h4>
<pre><code class="language-java">int getPosition(@NonNull View view) 
</code></pre>
<p>获取View的layout position，这个方法十分有用，也没啥人讲到过。</p>
<pre><code class="language-java">int getDecoratedMeasuredWidth(@NonNull View child)
int getDecoratedMeasuredHeight(@NonNull View child)
</code></pre>
<p>获取View的宽高，并且是包含了ItemDecoration的占比。</p>
<pre><code class="language-java">int getDecoratedTop(@NonNull View child)
int getDecoratedLeft(@NonNull View child)
int getDecoratedRight(@NonNull View child)
int getDecoratedBottom(@NonNull View child)
</code></pre>
<p>获取View的left，top，right，bottom距离RecyclerView边缘的距离，同样包含了了ItemDecoration的占比。</p>
<h4 id="view_4">移动View</h4>
<pre><code class="language-java">offsetChildrenHorizontal(@Px int dx)
offsetChildrenVertical(@Px int dy)
</code></pre>
<p>水平或垂直方向的移动全部子View，看源码得知其实就是遍历调用了子View的<code>offsetTopAndBottom</code>或<code>offsetLeftAndRight</code>方法，这两个方法在自定义ViewGroup移动子View时也经常用到。</p>
<h4 id="view_5">回收View</h4>
<pre><code class="language-java">detachAndScrapAttachedViews(@NonNull Recycler recycler)
detachAndScrapView(@NonNull View child, @NonNull Recycler recycler)
detachAndScrapViewAt(int index, @NonNull Recycler recycler)

removeAndRecycleAllViews(@NonNull Recycler recycler)
removeAndRecycleView(@NonNull View child, @NonNull Recycler recycler)
removeAndRecycleViewAt(int index, @NonNull Recycler recycler)
</code></pre>
<p>上面几个方法只要记住是<code>detachAndScrap</code>开头的就是轻量级的回收View，马上又要添加View回来。<code>removeAndRecycle</code>开头的就是加强版的回收View，当再次添加View回来时会执行<code>onBindViewHolder</code>方法。</p>
<p>我看网上没啥博客真正讲清楚什么时候该用哪个方法来回收View的，这里有个简单的办法区分什么时候该用哪一个回收View的方法，那就是：</p>
<ul>
<li>
<p>在<code>onLayoutChildren</code>回收View使用<code>detachAndScrap</code>的系列方法，因为onLayoutChildren方法会连续多次调用，<code>detachAndScrap</code>系列的方法就是用在这时候。</p>
</li>
<li>
<p>在<code>滚动发生后</code>要回收超出屏幕不可见的View时用<code>removeAndRecycle</code>的系列方法。</p>
</li>
</ul>
<p>别问我为啥知道，因为我看<code>LinearLayoutManager</code>和<code>StaggeredGridLayoutManager</code>也是这么用的，嘻嘻！read the fucking source code~</p>
<h4 id="orientationhelper">OrientationHelper帮助类</h4>
<p><img alt="img_orientation_helper.png" src="https://i.loli.net/2020/09/08/AD6sjHya9NnpcFW.png" /></p>
<p>这个帮助类值得好好夸赞，这也是我在阅读<code>LinearLayoutManager</code>源码时发现的，OrientationHelper是一个抽象类，抽象了大量便利的方法，并且提供了两个静态方法<code>createHorizontalHelper</code>和<code>createVerticalHelper</code>用来创建相应方向的帮助类供开发者使用。使用OrientationHelper可以大大减少如下我在<a href="https://github.com/simplepeng/StackLayoutManager">StackLayoutManager</a>的样板代码。</p>
<pre><code class="language-kotlin">    /**
     * 移动所有子view
     */
    private fun offsetChildren(amount: Int) {
        if (orientation == HORIZONTAL) {
            offsetChildrenHorizontal(amount)
        } else {
            offsetChildrenVertical(amount)
        }
    }
...
    private fun getTotalSpace(): Int {
        return if (orientation == HORIZONTAL) {
            width - paddingLeft - paddingRight
        } else {
            height - paddingTop - paddingBottom
        }
    }
</code></pre>
<h2 id="layoutmanager_4">正式开始自定义LayoutManager</h2>
<p>现在我们开始正式讲解如何自定义一个LayoutManager，大概步骤就是如上面<code>自定义LayoutManager的常规套路</code>一样，并且我会用我写的两个开源库<a href="https://github.com/simplepeng/PickerLayoutManager">PickerLayoutManager</a>和<a href="https://github.com/simplepeng/StackLayoutManager">StackLayoutManager</a>来讲解，喜欢的可以<code>star</code>一下。</p>
<table>
<thead>
<tr>
<th>https://github.com/simplepeng/StackLayoutManager</th>
<th>https://github.com/simplepeng/PickerLayoutManager</th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="img_stack_layout_manager.png" src="https://i.loli.net/2020/09/08/iHwhxlT5Ddm2ECg.png" /></td>
<td><img alt="img_picker_layout_manager.png" src="https://i.loli.net/2020/09/08/Bk1pQf43EyOjxIe.png" /></td>
</tr>
</tbody>
</table>
<h4 id="layoutmanagergeneratedefaultlayoutparams">继承LayoutManager并实现generateDefaultLayoutParams()方法</h4>
<p>这没啥好说的，<code>generateDefaultLayoutParams</code>是抽象方法，继承LayoutManager就必须实现，你自定义的LayoutManager的itemView支持啥LayoutParams就写哪种，比如我写的<a href="https://github.com/simplepeng/PickerLayoutManager">PickerLayoutManager</a>和<a href="https://github.com/simplepeng/StackLayoutManager">StackLayoutManager</a>就是不同的实现。</p>
<pre><code class="language-kotlin">class PickerLayoutManager:: RecyclerView.LayoutManager(){
      override fun generateDefaultLayoutParams(): RecyclerView.LayoutParams {
        return if (orientation == HORIZONTAL) {
            RecyclerView.LayoutParams(
                RecyclerView.LayoutParams.WRAP_CONTENT,
                RecyclerView.LayoutParams.MATCH_PARENT
            )
        } else {
            RecyclerView.LayoutParams(
                RecyclerView.LayoutParams.MATCH_PARENT,
                RecyclerView.LayoutParams.WRAP_CONTENT
            )
        }
    }
}
</code></pre>
<pre><code class="language-kotlin">class StackLayoutManager: RecyclerView.LayoutManager(){
      override fun generateDefaultLayoutParams(): RecyclerView.LayoutParams {
        return RecyclerView.LayoutParams(
            ViewGroup.LayoutParams.WRAP_CONTENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
        )
    }
}
</code></pre>
<h4 id="onmeasureisautomeasureenabled_1">重写onMeasure()或isAutoMeasureEnabled()方法。</h4>
<pre><code class="language-kotlin">class PickerLayoutManager:: RecyclerView.LayoutManager(){
      override fun onMeasure(
        recycler: RecyclerView.Recycler,
        state: RecyclerView.State,
        widthSpec: Int,
        heightSpec: Int
    ) {
        if (state.itemCount == 0) {
            super.onMeasure(recycler, state, widthSpec, heightSpec)
            return
        }
        if (state.isPreLayout) return

        //假定每个item的宽高一直，所以用第一个view计算宽高，
        //这种方式可能不太好
        val itemView = recycler.getViewForPosition(0)
        addView(itemView)
        //这里不能用measureChild方法，具体看内部源码实现，内部getWidth默认为0
//        measureChildWithMargins(itemView, 0, 0)
        itemView.measure(widthSpec, heightSpec)
        mItemWidth = getDecoratedMeasuredWidth(itemView)
        mItemHeight = getDecoratedMeasuredHeight(itemView)
        //回收这个View
        detachAndScrapView(itemView, recycler)

        //设置宽高
        setWidthAndHeight(mItemWidth, mItemHeight)
    }

      private fun setWidthAndHeight(
        width: Int,
        height: Int
    ) {
        if (orientation == HORIZONTAL) {
            setMeasuredDimension(width * visibleCount, height)
        } else {
            setMeasuredDimension(width, height * visibleCount)
        }
    }
}
</code></pre>
<pre><code class="language-kotlin">class StackLayoutManager: RecyclerView.LayoutManager(){
      override fun isAutoMeasureEnabled(): Boolean {
        return true
    }
}
</code></pre>
<p>从上面代码可以看出，<code>PickerLayoutManager</code>重写了<code>onMeasure()</code>，<code>StackLayoutManager</code>重写了<code>isAutoMeasureEnabled()</code>方法，跟上面常见误区中的讲得一致。</p>
<h4 id="onlayoutchildrenview">重写onLayoutChildren()开始填充子View。</h4>
<p>从这个方法开始，<a href="https://github.com/simplepeng/PickerLayoutManager">PickerLayoutManager</a>和<a href="https://github.com/simplepeng/StackLayoutManager">StackLayoutManager</a>的套路都是一致的：计算剩余空间-&gt;addView()-&gt;measureView()-&gt;layoutView()。因为都是模仿<code>LinearLayoutManager</code>的写法，所以下面开始只用<code>StackLayoutManager</code>的<code>伪代码</code>作代码示例，特别的地方再用不同实现的代码做比较。</p>
<p>记住下面的大多数都是<code>伪代码</code>，不要直接复制运行，因为<code>StackLayoutManager</code>支持的属性很多，包括了如同<code>LinearLayoutManager</code>的<code>reverseLayout</code>和<code>orientation</code>等，并且下面的示例只会讲<code>orientation==HORIZONTAL</code>的代码实现，主要是怕代码逻辑太复杂不好理解，想看具体源码的可以点击上面的源码链接查看。</p>
<pre><code class="language-kotlin">    override fun onLayoutChildren(recycler: RecyclerView.Recycler, state: RecyclerView.State) {

        //轻量级的将view移除屏幕
        detachAndScrapAttachedViews(recycler)
        //开始填充view

        var totalSpace = width - paddingRight
        var currentPosition = 0

        var left = 0
        var top = 0
        var right = 0
        var bottom = 0
        //模仿LinearLayoutManager的写法，当可用距离足够和要填充
        //的itemView的position在合法范围内才填充View
        while (totalSpace &gt; 0 &amp;&amp; currentPosition &lt; state.itemCount) {
            val view = recycler.getViewForPosition(currentPosition)
            addView(view)
            measureChild(view, 0, 0)

            right = left + getDecoratedMeasuredWidth(view)
            bottom = top + getDecoratedMeasuredHeight(view)
            layoutDecorated(view, left, top, right, bottom)

            currentPosition++
            left += getDecoratedMeasuredWidth(view)
            //关键点
            totalSpace -= getDecoratedMeasuredWidth(view)
        }
        //layout完成后输出相关信息
        logChildCount(&quot;onLayoutChildren&quot;, recycler)
    }
</code></pre>
<p>上面的代码很简单了，相信写过自定义ViewGroup的人都能看懂。上面代码很简单的实现了一个<code>横向的LinearLayoutManager</code>，如图所示：</p>
<p><img alt="img_blog_lm_on_layout.png" src="https://i.loli.net/2020/09/08/dOY2TqHgxeS1oL8.png" /></p>
<p>并且在<code>layout</code>结束后，增加了一个输出<code>childCount</code>的方法。</p>
<pre><code class="language-kotlin">    private fun logChildCount(tag: String, recycler: RecyclerView.Recycler) {
        Log.d(tag, &quot;childCount = $childCount -- scrapSize = ${recycler.scrapList.size}&quot;)
    }
</code></pre>
<blockquote>
<p>D/onLayoutChildren: childCount = 9 -- scrapSize = 0
D/onLayoutChildren: childCount = 9 -- scrapSize = 0
D/onLayoutChildren: childCount = 9 -- scrapSize = 0</p>
</blockquote>
<p>从图中可以看出，我们摆放了position<code>0-8</code>的itemView，所以<code>childCount=9</code>，并且<code>scrapSize=0</code>，所以我们这个方法写得是合格的。因为我们用<code>totalSpace &gt; 0</code>作了<code>while</code>表达式的判断，所以并不用关心<code>itemCount</code>有多大。</p>
<h4 id="canscrollhorizontallycanscrollvertically">重写canScrollHorizontally()和canScrollVertically()方法支持滑动。</h4>
<p>上面已经初始化摆放了一些itemView，但是RecyclerView还是不能滑动的，不信的可以试试。我们必须重写下面两个方法，RecyclerView才会将滑动的事件交给LayoutManager。</p>
<pre><code class="language-kotlin">    override fun canScrollHorizontally(): Boolean {
        return orientation == HORIZONTAL
    }

    override fun canScrollVertically(): Boolean {
        return orientation == VERTICAL
    }
</code></pre>
<p>没啥好说的，想支持哪个方向的滑动，就返回<code>true</code>。同时返回true都可以，那就是同时支持上下左右滑动，类似Dave大神那种表格类型的LayoutManager。</p>
<h4 id="scrollhorizontallybyscrollverticallybyviewview">重写scrollHorizontallyBy()和scrollVerticallyBy()方法在滑动的时候填充view和回收view。</h4>
<pre><code class="language-kotlin">override fun scrollHorizontallyBy(
    dx: Int,
    recycler: RecyclerView.Recycler,
    state: RecyclerView.State
): Int {
    return super.scrollHorizontallyBy(dx, recycler, state)
}
</code></pre>
<p>这里先讲一下<code>scrollHorizontallyBy</code>和<code>scrollVerticallyBy</code>两个滑动方法的概念：</p>
<ul>
<li>我看一些博客下有些评论说："实现这两个方法也不能滑动啊！"，说是说这两个方法是滑动的方法，但是其实这两个方法只会返回手指在RecyclerView上的移动距离给我们，就是方法中对应的<code>dx</code>和<code>dy</code>，<code>dx&gt;0</code>就是手指<code>从右滑向左</code>，<code>dy&gt;0</code>就是手指<code>从下滑向上</code>，同理<code>dx,dy&lt;0</code>则反，真正移动View的事情还是要开发者自己实现，<code>LinearLayoutManager</code>中就简单的用<code>offsetChildren</code>方法实现的移动。或者也有的评论说："LayoutManager封装的不够合理，滑动还要我们自己实现！"，讲道理说这种话的小朋友还是世面见少了，他肯定没见过可以斜着拖的LayoutManager，或者在滑动的时候对itemView有种各种变换的LayoutManager，嘻嘻。</li>
<li>两个方法的<code>返回值</code>同样也十分重要，返回值就是让RecyclerView知道LayoutManager真实的滑动距离，<code>return 0</code>时RecyclerView就会展示<code>overScorll</code>状态以及<code>NestedScrolling</code>的后续处理。关于<code>NestedScrolling</code>这点我也没发现有博客讲到，啥？overScorll你也不知道！告辞~</li>
</ul>
<p>添加<code>offsetChildrenHorizontal</code>方法，支持水平方向的滑动。啥？为啥又是<code>-dx</code>，看看源码或者实验实验不就知道了。</p>
<pre><code class="language-kotlin">    override fun scrollHorizontallyBy(
        dx: Int,
        recycler: RecyclerView.Recycler,
        state: RecyclerView.State
    ): Int {
        //移动View
        offsetChildrenHorizontal(-dx)
        return dx
    }
</code></pre>
<p><img alt="gif_blog_lm_sroll_horizontal.gif" src="https://i.loli.net/2020/09/08/zphtQDd26m9Kgik.gif" /></p>
<p>就这么简单，我们的LayoutManager已经可以滑动了。但是随之而来又发现一个问题：“滑动只是在已存在的这几个children间滑动”。这不是废话吗，我们都没写填充和回收View的方法，肯定没有新的itemView添加进来呀，超过屏幕的View也不会回收呀。下面开始增加填充View和回收View的代码块。</p>
<pre><code class="language-kotlin">    override fun scrollHorizontallyBy(
        dx: Int,
        recycler: RecyclerView.Recycler,
        state: RecyclerView.State
    ): Int {

        //填充View
        fill(dx, recycler)
        //移动View
        offsetChildrenHorizontal(-dx)
        //回收View
        recycle(dx, recycler)

        //输出children
        logChildCount(&quot;scrollHorizontallyBy&quot;, recycler)
        return dx
    }
</code></pre>
<p>从上面的代码可以看出，在滑动的时候我们真正只做了三件事，<code>填充View</code>-<code>移动View</code>-<code>回收View</code>，一个合格的LayoutManager<code>至少</code>是应该做足这三件事的，并且顺序最好如上面代码一样<code>先填充-再移动-最后回收</code>，当然复杂的情况的LayoutManager可以多加一些条件检测和特殊处理，例如<code>LinearLayoutManager</code>就是<code>先回收-再填充-再回收-最后移动</code>。</p>
<p>这里我们先写回收的方法，因为逻辑相对简单点。</p>
<pre><code class="language-kotlin">    private fun recycle(
        dx: Int,
        recycler: RecyclerView.Recycler
    ) {
        //要回收View的集合，暂存
        val recycleViews = hashSetOf&lt;View&gt;()

        //dx&gt;0就是手指从右滑向左，所以要回收前面的children
        if (dx &gt; 0) {
            for (i in 0 until childCount) {
                val child = getChildAt(i)!!
                val right = getDecoratedRight(child)
                //itemView的right&lt;0就是要超出屏幕要回收View
                if (right &gt; 0) break
                recycleViews.add(child)
            }
        }

        //dx&lt;0就是手指从左滑向右，所以要回收后面的children
        if (dx &lt; 0) {
            for (i in childCount - 1 downTo 0) {
                val child = getChildAt(i)!!
                val left = getDecoratedLeft(child)

                //itemView的left&gt;recyclerView.width就是要超出屏幕要回收View
                if (left &lt; width) break
                recycleViews.add(child)
            }
        }

        //真正把View移除掉
        for (view in recycleViews) {
            removeAndRecycleView(view, recycler)
        }
        recycleViews.clear()
    }
</code></pre>
<p><img alt="gif_blog_lm_sroll_recycle.gif" src="https://i.loli.net/2020/09/08/eDi39jlEJFLT2hr.gif" /></p>
<p>可以看到我们在拖动是时候，LayoutManager确实回收了超出屏幕的itemView，并且通过查看log可知childCount和scrapSize同样是合格的。</p>
<blockquote>
<p>D/scrollHorizontallyBy: childCount = 2 -- scrapSize = 0</p>
</blockquote>
<p>接下来才是重头戏，如何合理的填充View是一门学问。通过我阅读<code>LinearLayoutManager</code>的源码，也总结出一个套路，那就是：<code>获取锚点View的position</code>，<code>计算新的锚点View的position和位置</code>，然后和<code>onLayoutChildren</code>方法一样<code>addView</code>，<code>measureView</code>，<code>layoutView</code>。</p>
<pre><code class="language-kotlin">    private fun fill(dx: Int, recycler: RecyclerView.Recycler): Int {
        //将要填充的position
        var fillPosition = RecyclerView.NO_POSITION
        //可用的空间，和onLayoutChildren中的totalSpace类似
        var availableSpace = abs(dx)
        //增加一个滑动距离的绝对值，方便计算
        val absDelta = abs(dx)

        //将要填充的View的左上右下
        var left = 0
        var top = 0
        var right = 0
        var bottom = 0

        //dx&gt;0就是手指从右滑向左，所以就要填充尾部
        if (dx &gt; 0) {
            val anchorView = getChildAt(childCount - 1)!!
            val anchorPosition = getPosition(anchorView)
            val anchorRight = getDecoratedRight(anchorView)

            left = anchorRight
            //填充尾部，那么下一个position就应该是+1
            fillPosition = anchorPosition + 1

            //如果要填充的position超过合理范围并且最后一个View的
            //right-移动的距离 &lt; 右边缘(width)那就要修正真实能移动的距离
            if (fillPosition &gt;= itemCount &amp;&amp; anchorRight - absDelta &lt; width) {
                val fixScrolled = anchorRight - width
                Log.d(&quot;scrollHorizontallyBy&quot;, &quot;fill == $fixScrolled&quot;)
                return fixScrolled
            }

            //如果尾部的锚点位置减去dx还是在屏幕外，就不填充下一个View
            if (anchorRight - absDelta &gt; width) {
                return dx
            }
        }

        //dx&lt;0就是手指从左滑向右，所以就要填充头部
        if (dx &lt; 0) {
            val anchorView = getChildAt(0)!!
            val anchorPosition = getPosition(anchorView)
            val anchorLeft = getDecoratedLeft(anchorView)

            right = anchorLeft
            //填充头部，那么上一个position就应该是-1
            fillPosition = anchorPosition - 1

            //如果要填充的position超过合理范围并且第一个View的
            //left+移动的距离 &gt; 左边缘(0)那就要修正真实能移动的距离
            if (fillPosition &lt; 0 &amp;&amp; anchorLeft + absDelta &gt; 0) {
                return anchorLeft
            }

            //如果头部的锚点位置加上dx还是在屏幕外，就不填充上一个View
            if (anchorLeft + absDelta &lt; 0) {
                return dx
            }
        }

        //根据限定条件，不停地填充View进来
        while (availableSpace &gt; 0 &amp;&amp; (fillPosition in 0 until itemCount)) {
            val itemView = recycler.getViewForPosition(fillPosition)

            if (dx &gt; 0) {
                addView(itemView)
            } else {
                addView(itemView, 0)
            }

            measureChild(itemView, 0, 0)

            if (dx &gt; 0) {
                right = left + getDecoratedMeasuredWidth(itemView)
            } else {
                left = right - getDecoratedMeasuredWidth(itemView)
            }

            bottom = top + getDecoratedMeasuredHeight(itemView)
            layoutDecorated(itemView, left, top, right, bottom)

            if (dx &gt; 0) {
                left += getDecoratedMeasuredWidth(itemView)
                fillPosition++
            } else {
                right -= getDecoratedMeasuredWidth(itemView)
                fillPosition--
            }

            if (fillPosition in 0 until itemCount) {
                availableSpace -= getDecoratedMeasuredWidth(itemView)
            }
        }

        return dx
    }
</code></pre>
<p>上面的代码我故意写得很啰嗦，应该很好理解了。而且聪明的宝宝应该发现了这个<code>fill</code>方法跟<code>onLayoutChildren</code>的方法是很耦合的，其实是可以合并成一个的，就像<code>LinearLayoutManager</code>的<code>fill</code>方法一样。还有就是再次记住上面的代码是用来讲解的伪代码，并不是<code>StackLayoutManager</code>的真实代码，为了容易理解，我删除了大量的检测方法，以及写的非常啰嗦。</p>
<p><img alt="gif_blog_lm_sroll_fill.gif" src="https://i.loli.net/2020/09/08/ZarPh2Fvwli8ySt.gif" /></p>
<blockquote>
<p>D/scrollHorizontallyBy: childCount = 9 -- scrapSize = 0
D/scrollHorizontallyBy: childCount = 10 -- scrapSize = 0</p>
</blockquote>
<p>现在我们的LayoutManager就以及支持了在滑动的时候填充View和回收View，并且childCount依然是合格的。</p>
<p>剩下的就是边界检测让其支持<code>overScrollMode</code>了，细心的小朋友已经发现<code>fill</code>方法其实有一个<code>Int</code>的返回值，那么现在<code>offsetChildren</code>和<code>scrollHorizontallyBy</code>的返回值都使用<code>fill</code>方法的返回值。</p>
<pre><code class="language-kotlin">    override fun scrollHorizontallyBy(
        dx: Int,
        recycler: RecyclerView.Recycler,
        state: RecyclerView.State
    ): Int {

        //填充View，consumed就是修复后的移动值
        val consumed = fill(dx, recycler)
        //移动View
        offsetChildrenHorizontal(-consumed)
        //回收View
        recycle(consumed, recycler)

        //输出children
        logChildCount(&quot;scrollHorizontallyBy&quot;, recycler)
        return consumed
    }
</code></pre>
<p><img alt="gif_blog_lm_sroll_fill_edge.gif" src="https://i.loli.net/2020/09/09/GWID8K5csQyzYAo.gif" /></p>
<p>就这样简单，边缘检测也完成了。</p>
<h4 id="scrolltopositionsmoothscrolltoposition_1">scrollToPosition()和smoothScrollToPosition()方法支持。</h4>
<h5 id="scrolltoposition">适配 scrollToPosition()</h5>
<p>源码是最好的老师，我们看看<code>LinearLayoutManager</code>的<code>scrollToPosition()</code>是如何实现的。</p>
<pre><code class="language-java">    //LinearLayoutManager
        @Override
    public void scrollToPosition(int position) {
        mPendingScrollPosition = position;
        mPendingScrollPositionOffset = INVALID_OFFSET;
        if (mPendingSavedState != null) {
            mPendingSavedState.invalidateAnchor();
        }
        requestLayout();
    }
</code></pre>
<p>原来这么简单的吗？再看看<code>mPendingScrollPosition</code>是个啥。</p>
<pre><code class="language-java">    /**
     * When LayoutManager needs to scroll to a position, it sets this variable and requests a
     * layout which will check this variable and re-layout accordingly.
     */
    int mPendingScrollPosition = RecyclerView.NO_POSITION;
</code></pre>
<p>从英文注释的大概的意思就是<code>mPendingScrollPosition</code>是要scorll到的position，那我们继续找它是在哪里调用的。在一连串的搜索后，我发现了华点。</p>
<pre><code class="language-java">    private boolean updateAnchorFromPendingData(RecyclerView.State state, AnchorInfo anchorInfo) {
        if (state.isPreLayout() || mPendingScrollPosition == RecyclerView.NO_POSITION) {
            return false;
        }
        // validate scroll position
        if (mPendingScrollPosition &lt; 0 || mPendingScrollPosition &gt;= state.getItemCount()) {
            mPendingScrollPosition = RecyclerView.NO_POSITION;
            mPendingScrollPositionOffset = INVALID_OFFSET;
            if (DEBUG) {
                Log.e(TAG, &quot;ignoring invalid scroll position &quot; + mPendingScrollPosition);
            }
            return false;
        }

        // if child is visible, try to make it a reference child and ensure it is fully visible.
        // if child is not visible, align it depending on its virtual position.
        anchorInfo.mPosition = mPendingScrollPosition;
      ...
    }
</code></pre>
<p>这个<code>updateAnchorFromPendingData()</code>方法有多层调用栈，但是最终还是在<code>onLayoutChildren()</code>方法中调用的。还记得我们最开始在<code>onLayuoutChildren()</code>有个<code>currentPosition = 0</code>的变量吗，那个变量就相当于这里的<code>anchorInfo.mPosition</code>，就是<code>锚点的position</code>，那么现在我们就可以得出如何适配scrollToPosition的结论：增加mPendingScrollPosition变量，在scrollToPosition()方法中对其赋值，调用requestLayout()方法，然后onLayoutChildren()方法会再次回调，这时对锚点position重新赋值，记住一定做好position的合法校验。</p>
<pre><code class="language-kotlin">        private var mPendingPosition = RecyclerView.NO_POSITION

    override fun onLayoutChildren(recycler: RecyclerView.Recycler, state: RecyclerView.State) {
                ...省略代码

        var currentPosition = 0
        if (mPendingPosition != RecyclerView.NO_POSITION){
            currentPosition = mPendingPosition
        }

        ...省略代码
    }

    override fun scrollToPosition(position: Int) {
        if (position &lt; 0 || position &gt;= itemCount) return
        mPendingPosition = position
        requestLayout()
    }
</code></pre>
<p><img alt="gif_blog_lm_sroll_to_position.gif" src="https://i.loli.net/2020/09/10/jN8VHoMxGePBhA7.gif" /></p>
<p>仔细看，我们的LayoutManager是不是可以scrollToPosition了。但是这还不是完整的实现，如果你仔细对比<code>LinearLayuotManager</code>的scrollToPosition就能发现差别所在，我这里只是抛砖引玉一下，能让大家知道如何适配scrollToPosition就行了，完整的实现大多数就是细节的处理，和套路无关，听懂掌声👏👏👏👏。</p>
<p>还有一点我看大多数的博客也没讲到，那就是<code>onLayoutCompleted()</code>这个方法其实挺有用的，为啥没人说呢？<code>onLayoutCompleted</code>会在LayoutManager调用完<code>onLayoutChildren()</code>后调用，可以用来做很多收尾的工作。例如：重置mPendingScrollPosition的值</p>
<pre><code class="language-java">    //LinearLayoutManager
        @Override
    public void onLayoutCompleted(RecyclerView.State state) {
        super.onLayoutCompleted(state);
        mPendingSavedState = null; // we don't need this anymore
        mPendingScrollPosition = RecyclerView.NO_POSITION;
        mPendingScrollPositionOffset = INVALID_OFFSET;
        mAnchorInfo.reset();
    }
</code></pre>
<h5 id="smoothscrolltoposition">适配smoothScrollToPosition()</h5>
<p>继续扒<code>LinearLayuotManager</code>的<code>smoothScrollToPosition</code>的源码。</p>
<pre><code class="language-java">    //LinearLayuotManager
        @Override
    public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state,
            int position) {
        LinearSmoothScroller linearSmoothScroller =
                new LinearSmoothScroller(recyclerView.getContext());
        linearSmoothScroller.setTargetPosition(position);
        startSmoothScroll(linearSmoothScroller);
    }
</code></pre>
<p>九折？不管了，直接复制，粘贴，再看效果，毕竟祖传CV工程师岂非浪得虚名。</p>
<pre><code class="language-kotlin">    override fun smoothScrollToPosition(
        recyclerView: RecyclerView,
        state: RecyclerView.State,
        position: Int
    ) {
        val linearSmoothScroller =
            LinearSmoothScroller(recyclerView.context)
        linearSmoothScroller.targetPosition = position
        startSmoothScroll(linearSmoothScroller)
    }
</code></pre>
<p><img alt="gif_blog_lm_smooth_sroll_to_position_1.gif" src="https://i.loli.net/2020/09/10/7Ri96fjVWIbXaFT.gif" /></p>
<p>咦！这不是scrollToPosition的效果吗？也不是我们smoothScroll的平滑效果呀。于是我继续看博客，翻源码，也还是看到了Dave大神的博客才找到了真正的重点<code>computeScrollVectorForPosition(int targetPosition)</code>这个方法。这个方法就在<code>LinearLayoutManager</code>的<code>smoothScrollToPosition</code>方法下面，但是没有注释，是真难让人猜。</p>
<pre><code class="language-java">    @Override
    public PointF computeScrollVectorForPosition(int targetPosition) {
        if (getChildCount() == 0) {
            return null;
        }
        final int firstChildPos = getPosition(getChildAt(0));
        final int direction = targetPosition &lt; firstChildPos != mShouldReverseLayout ? -1 : 1;
        if (mOrientation == HORIZONTAL) {
            return new PointF(direction, 0);
        } else {
            return new PointF(0, direction);
        }
    }
</code></pre>
<p>这个<code>computeScrollVectorForPosition</code>方法是<code>SmoothScroller</code>类的一个方法。<code>LinearSmoothScroller</code>又是继承于<code>SmoothScroller</code>。</p>
<pre><code class="language-java">        @Nullable
        public PointF computeScrollVectorForPosition(int targetPosition) {
            LayoutManager layoutManager = getLayoutManager();
            if (layoutManager instanceof ScrollVectorProvider) {
                return ((ScrollVectorProvider) layoutManager)
                        .computeScrollVectorForPosition(targetPosition);
            }
            Log.w(TAG, &quot;You should override computeScrollVectorForPosition when the LayoutManager&quot;
                    + &quot; does not implement &quot; + ScrollVectorProvider.class.getCanonicalName());
            return null;
        }
</code></pre>
<p>从源码来看，又在判断LayoutManager是否是ScrollVectorProvider的子类。如果是就执行computeScrollVectorForPosition方法，那么这样来说的话LinearLayoutManager肯定实现了ScrollVectorProvider接口。</p>
<pre><code class="language-java">public class LinearLayoutManager extends RecyclerView.LayoutManager implements
        ItemTouchHelper.ViewDropHandler, RecyclerView.SmoothScroller.ScrollVectorProvider {
</code></pre>
<p>果然和我们猜想的一样，那么我们也继续模仿这种写法。</p>
<pre><code class="language-kotlin">class BlogLayoutManager : RecyclerView.LayoutManager() ,RecyclerView.SmoothScroller.ScrollVectorProvider{
          override fun computeScrollVectorForPosition(targetPosition: Int): PointF? {
        if (childCount == 0) {
            return null
        }
        val firstChildPos = getPosition(getChildAt(0)!!)
        val direction = if (targetPosition &lt; firstChildPos) -1 else 1
        return PointF(direction.toFloat(), 0f)
    }
}
</code></pre>
<p><img alt="gif_blog_lm_smooth_sroll_to_position_2.gif" src="https://i.loli.net/2020/09/10/laMBNjeKUXdvGV6.gif" /></p>
<p>细心的小朋友又发现了，我们平滑滚动到<code>50</code>这个position，但是<code>50</code>是靠后停止的，并不是滚动到前面边缘的位置停止。没错，正确的效果就是这样，包括<code>LinearLayoutManager</code>的<code>smoothScrollToPosition</code>的效果也是这样。所以前面我才会说<code>scrollToPosition</code>的实现不是完整效果，完整效果应该和<code>smoothScrollToPosition</code>一样，scrollToPosition到后面的position就是应该<code>从后往前填充</code>，scrollToPosition到前面的position才是<code>从前往后填充</code>。</p>
<p>接着我们讲讲<code>computeScrollVectorForPosition</code>这个方法里面的实现套路。</p>
<pre><code class="language-kotlin">val firstChildPos = getPosition(getChildAt(0)!!)
val direction = if (targetPosition &lt; firstChildPos) -1 else 1
return PointF(direction.toFloat(), 0f)
</code></pre>
<p>通过我阅读源码注释得知，重点就在这个<code>PointF</code>的返回值，源码注释中告诉我们向量的大小并不重要，重要的是<code>targetPosition</code>和<code>向量的方向</code>，<code>PointF</code>的<code>x</code>代表水平方向，<code>y</code>代表竖直方向。<code>整数</code>代表正向移动，<code>负数</code>代表反向移动，也就是上面代码中的<code>direction</code>。但是其实这个说法也不是全对，如果你需要而且能够算出精确的移动值，那就可以直接传递精确的值给<code>PointF</code>。</p>
<h4 id="onlayoutchildren_1">解决软键盘弹出或收起onLayoutChildren()方法重新调用的问题。</h4>
<p>这个问题我也是无意中发现的。</p>
<p><img alt="gif_blog_lm_keyborad.gif" src="https://i.loli.net/2020/09/10/PO7J4EVCkbtjpHu.gif" /></p>
<p>如图所示，我们在滚动一段距离后，让软键盘弹出，发现LayoutManager自动回到<code>position=0</code>那里，再滚动一段距离，软键盘收起，LayoutManager又自动回到<code>position=0</code>那里。分析原因可以知道是<code>onLayoutChildren</code>方法被重新调用导致，因为<code>onLayoutChildren</code>方法中我们的<code>currentPosition=0</code>，所以导致了LayoutManager从0开始重新布局。下面我们开始修正position为真实滚动后的值。</p>
<pre><code class="language-kotlin">    override fun onLayoutChildren(recycler: RecyclerView.Recycler, state: RecyclerView.State) {

        var totalSpace = width - paddingRight

        var currentPosition = 0

        //当childCount != 0时，证明是已经填充过View的，因为有回收
        //所以直接赋值为第一个child的position就可以
        if (childCount != 0) {
            currentPosition = getPosition(getChildAt(0)!!)
        }

        if (mPendingPosition != RecyclerView.NO_POSITION) {
            currentPosition = mPendingPosition
        }

        //轻量级的将view移除屏幕
        detachAndScrapAttachedViews(recycler)

        //开始填充view
        var left = 0
      ...省略代码
    }
</code></pre>
<p>上面示例代码注意<code>detachAndScrapAttachedViews(recycler)</code>方法是在<code>修正position</code>方法的后面，因为先调用<code>detachAndScrapAttachedViews</code>后，childCount就会一直为<code>0</code>啊！</p>
<p><img alt="gif_blog_lm_keyborad_fix.gif" src="https://i.loli.net/2020/09/10/Af4yXWcCgY8n7ko.gif" /></p>
<p>还是如图所示，我们拖动到了<code>position=25</code>的itemView那里，然后软键盘弹起<code>onLayoutChildren</code>调用，这次的确是从<code>currentPosition=25</code>开始重新布局。</p>
<p>但是现在这个方法也还是有瑕疵，仔细看图，我们发现<code>position=25</code>的itemView明明被拖动了一般的宽度到屏幕外，但是重新<code>onLayoutChildren</code>时，又是从屏幕左边缘开始layoutView了。那么怎么解决呢？我们还是可以学习<code>LinearLayoutManager</code>的解决办法，开始获取一个<code>fixOffset</code>的值，在重新layout结束去移动这个值的距离，<code>LinearLayoutManager</code>是将滑动，填充，回收封装成了一个<code>scrollBy()</code>方法，然后在layout结束调用scrollBy方法去修正偏移量，这么做可以解决偏移滑动的同时填充和回收View，我这里偷个懒，直接用<code>offsetChildren</code>去修正一下偏移量。</p>
<pre><code class="language-kotlin">    override fun onLayoutChildren(recycler: RecyclerView.Recycler, state: RecyclerView.State) {

        var totalSpace = width - paddingRight

        var currentPosition = 0
        var fixOffset = 0

        //当childCount != 0时，证明是已经填充过View的，因为有回收
        //所以直接赋值为第一个child的position就可以
        if (childCount != 0) {
            currentPosition = getPosition(getChildAt(0)!!)
            fixOffset = getDecoratedLeft(getChildAt(0)!!)
        }
                //...省略代码
        offsetChildrenHorizontal(fixOffset)
    }
</code></pre>
<p><img alt="gif_blog_lm_keyborad_fix_2.gif" src="https://i.loli.net/2020/09/10/vqFE3rkwBot1DVi.gif" /></p>
<p>OK~，收工！啥？要实现的一个<code>StackLayoutManager</code>，为啥你这个是<code>LinearLayoutManger</code>！都看到这里了如果你还能有这种问题，证明我写了一篇水文，逃~</p>
<p><a href="https://github.com/simplepeng/StackLayoutManager/blob/master/app/src/main/java/demo/simple/stacklayoutmanager/BlogLayoutManager.kt">上面的伪代码示例</a></p>
<h2 id="_1">最后</h2>
<p>学习自定义LayoutManager的收获挺多的，特别是一些逻辑上的处理，由衷的佩服RecyclerView的作者，真的啥情况都考虑到了。虽然说日常使用RecyclerView自带的那几个LayoutManager就够用了，但是学习一下自定义LayoutManager也不妨，而且深入了还可以同时加深对RecyclerView的理解，何乐而不为呢~</p>
<p>从开始学习自定义LayoutManager，到写了几个开源库，再到完成这篇文章，断断续续花了一个多月吧，如果你觉得这篇文章有帮助你，帮忙给文章点个赞或者给开源库一个star吧，让我知道付出还是会有收获的，谢谢~</p>
<p>https://github.com/simplepeng/StackLayoutManager</p>
<p>https://github.com/simplepeng/PickerLayoutManager</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../%E5%9C%A8Activity%E7%9A%84onCreate%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B0%83%E7%94%A8finish%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="btn btn-neutral float-left" title="Activity的onCreate中调用finish的生命周期"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1%E7%A0%94%E7%A9%B6/" class="btn btn-neutral float-right" title="无障碍服务研究">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/simplepeng/blog" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../%E5%9C%A8Activity%E7%9A%84onCreate%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B0%83%E7%94%A8finish%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1%E7%A0%94%E7%A9%B6/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme_extra.js" defer></script>
    <script src="../../../js/theme.js" defer></script>
      <script src="../../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(false);
        };
    </script>

</body>
</html>
